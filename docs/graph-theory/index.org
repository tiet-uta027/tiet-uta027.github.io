#+options: toc:nil num:3 h:6
#+TITLE: Practice Questions for Graph Theory
#+SUBTITLE: Representation, Search Algorithms, and Variants for Problem Solving
#+AUTHOR: Raghav B. Venkataramaiyer
#+DATE: Feb '25
#+latex_header_extra: \usepackage{parskip}

#+md: [:material-file-pdf-box: Download this page as PDF](./index.pdf)

* COMMENT Auto Export to Md/Latex on save
#+begin_src emacs-lisp
  (setq bvr/mkdocs/hooks-to-update '(after-save-hook))
  (defun bvr/mkdocs/publish-hook ()
    (org-latex-export-to-pdf t)
    (org-md-export-to-markdown)
    (with-current-buffer (find-file-noselect (expand-file-name "index.md" default-directory))
      (save-excursion
        (goto-char (point-min))
        ;; (insert "---\ntoc_depth: 2\n---\n\n")
        (let* ((i 1)
               (boreg (pos-bol i))
               (eoreg (pos-eol i))
               _s)
          (while (not (eq boreg (point-max)))

            (setq _s (buffer-substring-no-properties boreg (+ 1 boreg)))
            (when (string= _s "#")
              (save-excursion (goto-char boreg)
                              (insert "#")))

            (setq i (+ i 1)
                  boreg (pos-bol i)
                  eoreg (pos-eol i)))))
      (save-buffer)
      (kill-buffer))
    )
  (cl-loop for hook in bvr/mkdocs/hooks-to-update
           do (add-hook hook
                        #'bvr/mkdocs/publish-hook
                        0 t))
#+end_src

#+RESULTS:

* Graph Representations

** Vertex Insertion
**** Question

$\overline{\mathit{ABCD}}$ is a closed quadrilateral.
A new vertex $E$ is introduced between $B$ and $C$.
Show the adjacency lists before and after the
introduction of $E$.  Hence, write an algorithm/
pseudocode in order to introduce a new vertex between
an existing edge.

**** Interpretation
Given a closed quadrilateral
$\overline{\mathit{ABCD}}$, the adjacency list in
1-indexed format is given as:

#+begin_example
  V = [A, B, C, D]
  Adj = [[2, 4],                  # 1 is connected to 2 and 4
         [1, 3],                  # 2 is connected to 1 and 3
         [2, 4],                  # and so forth
         [1, 3]]
#+end_example

Here the edge $\overline{\mathit{BC}}$ is defined in
two entries of the adjacency list, /i.e./ as vertex =3=
in =Adj[2]= and vertex =2= in =Adj[3]=.

**** Solution

In order to introduce a new vertex $E$ between edge
$\overline{\mathit{BC}}$,

***** Step 1
Append vertex $E$ to the vertex list $V$ and get its
index.

#+begin_example
  V = [A, B, C, D, E]             # Add E as V[5]
#+end_example

***** Step 2
Remove the edge  $\overline{\mathit{BC}}$
#+begin_example
  V = [A, B, C, D, E]
  Adj = [[2, 4],
         [1],                     # remove 3 from Adj[2]
         [4],                     # remove 2 from Adj[3]
         [1, 3],
         []]                      # add empty Adj[5]
#+end_example

***** Step 3
Add edges $\overline{\mathit{BEC}}$
#+begin_example
  V = [A, B, C, D, E]
  Adj = [[2, 4],
         [1, 5],                  # add 5 to Adj[2]
         [4, 5],                  # add 5 to Adj[3]
         [1, 3],
         [2, 3]]                  # add 2, 3 to Adj[5]
#+end_example

***** Algorithm

To introduce a vertex $W$ between an edge $(u,v)$,

#+begin_example
  GRAPH_ADD_VERTEX_BW(G,W,u,v) :
    w = G.V.append(W)             # Insert W into list of
                                  # vertices and store the
                                  # last appended index.

    G.Adj[u].remove(v)            # Remove v from Adj[u]
    G.Adj[v].remove(u)            # Remove u from Adj[v]

    G.Adj[u].append(w)            # Append w into Adj[u]
    G.Adj[v].append(w)            # Append w into Adj[v]

    G.Adj[w].append(u)            # Append u into Adj[w]
    G.Adj[w].append(v)            # Append v into Adj[w]
#+end_example

*PS*: Here, $W$ in uppercase refers to a variable
(/i.e./ vertex information like coordinates of a point
etc.) that needs to appended into the list of verts
$G.V$. And $(u,v)$ represent the indices of the pair of
verts that constitute and edge.  We are interested in
the Adjacency List (as required by the question,) hence
the use of $G.Adj$

** Transpose Graph

**** Question
Given a graph $G(V,M)$, $M$ being the adjacency matrix.
A transpose graph would be the one with same set of
vertices, but a transposed adjacency matrix, /i.e./
$G^{\top}(V,M^{\top})$. \\
What does a transpose graph represent?  Illustrate with
a drawing to support your answer.

**** Interpretation
Recall that,
1. In an adjacency matrix $A$, the component at
   $i^{\text{th}}$ row, and $j^{\text{th}}$ column is
   given as $a_{ij}$ and it represents whether the edge
   $v_{i}\to v_{j}$ exists.
2. A transpose graph $G^{\top}(V,M^{\top})$ would be
   any different /iff/ $M\ne M^{\top}$.  In other
   words, if $G$ is a directed graph.
3. The components in the transposed matrix are mirrored
   across the diagonal.  Hence, if $B = A^{\top}$, then
   $b_{ij} = a_{ji}$.

**** Solution

Each edge $v_{i}\to v_{j}$ in $G$, transforms to
$v_{j}\to v_{i}$ in the transpose graph $G^{\top}$.
In other words, the edges are reversed.

This would be any different only in case of a directed
graph.  Since for an undirected graph $M=M^{\top}$

Hence, the transpose graph $G^{\top}(V,M^{\top})$
represents $G(V,M)$ with edges reversed.

**** Illustration

[TODO]

** (In/Out)-degree 

**** Question
What is the average in-degree of a graph $G(V,E)$,
where $E$ is the set of edges in $G$?

**** Solution
In-degree of a vertex is defined as the number of
edges leading onto itself.

Let $d_{\mathrm{in}}(v)$ represent the in-degree of
vertex $v$.  Then the average in-degree is given as the
sum of in-degrees divided by the size of number of
verts,

\begin{align*}
  \mathbb{E}[d_{\mathrm{in}}(v)]
  &= \frac{\sum_{v\in V}d_{\mathrm{in}}(v)} {|V|}
\end{align*}

Intuitively speaking, the sum of all in-degrees is the
same as the number of edges. Hence,

\begin{align*}
  \mathbb{E}[d_{\mathrm{in}}(v)]
  &= \frac{|E|} {|V|}
\end{align*}

**** In further detail

In-degree of a vertex is the same as counting the
non-zeros in one (specific) column of an adjacency
matrix representation $M$ for the set of edges $E$.

Similarly, the sum $\sum_{v\in V}d_{\mathrm{in}}(v)$ is
equivalent to

+ Counting the non-zeros for every the column of $M$,
+ /i.e./ Counting all the non-zeros in $M$,
+ /i.e./ The number of edges.

Hence,

\begin{align*}
  \sum_{v\in V} d_{\mathrm{in}}(v)
    &= |E|
\end{align*}



** Representation

**** Question
Provide an adjacency list as well as the adjacency matrix
representation for trees A and B in the following figure.

#+md: <div class="grid" markdown>
#+md:
#+md: <div style="text-align:center" markdown>
#+md: ![](./images/treeA.png)  
#+md: Tree A
#+md: </div>
#+md:
#+md: <div style="text-align:center" markdown>
#+md: ![](./images/treeB.png)  
#+md: Tree B
#+md: </div>
#+md:
#+md: </div>

#+latex: \begin{figure}[!h]
#+latex: \centering
#+latex: \begin{minipage}{0.4\textwidth}
#+latex: \centering
#+latex: \includegraphics[width=\linewidth]{./images/treeA.png}
#+latex: 
#+latex: \subcaption{\label{fig:treeA} Tree A}
#+latex: \end{minipage}
#+latex: \begin{minipage}{0.5\textwidth}
#+latex: \centering
#+latex: \includegraphics[width=\linewidth]{./images/treeB.png}
#+latex: 
#+latex: \subcaption{\label{fig:treeB} Tree B}
#+latex: \end{minipage}
#+latex: \end{figure}

**** Solution

***** Tree A
#+begin_example
  Adj = [[2 3] 
         [1 4 5] 
         [1 6 7] 
         [2]
         [2]
         [3]
         [3]]

  M = [[0 1 1 0 0 0 0]
       [1 0 1 1 0 0 0]
       [1 0 0 0 1 1 0]
       [0 1 0 0 0 0 0]
       [0 1 0 0 0 0 0]
       [0 0 1 0 0 0 0]
       [0 0 1 0 0 0 0]]
#+end_example

***** Tree B
#+begin_example
  Adj = [[2]
         [1 3 4]
         [2]
         [2 6]
         [6]
         [4 5 7]
         [6]]
  M = [[0 1 0 0 0 0 0]
       [1 0 1 1 0 0 0]
       [0 1 0 0 0 0 0]
       [0 1 0 0 0 1 0]
       [0 0 0 0 0 1 0]
       [0 0 0 1 1 0 1]
       [0 0 0 0 0 1 0]]
#+end_example

***** PS
The Adjacency matrix of Tree B is bi-symmetric.

* Elementary Algorithms

** BFS

**** Question

#+md: <style>
#+md: .bvr-full-height-image-wrapper img {max-height: 30em}
#+md: </style>
#+md: <div class="grid" markdown>
#+md: <div class="bvr-full-height-image-wrapper" markdown>
#+attr_latex: :width 0.5\linewidth
#+caption: Graph A
#+name: fig:graphA
[[file:images/graphA.png]]
#+md: _Graph A_
#+md: </div>

#+md: <div markdown>
With reference to Graph A @@latex:(see
Fig~\ref{fig:graphA})@@ *Determine algorithmically*,

1. The shortest path weight $\delta(u,j)$ for the pair
   $(u,j)$ of vertices.
2. A shortest path between the pair $(u,j)$ of
   vertices.
3. All shortest-paths originating from vertex $u$.

#+md: </div>
#+md: </div>

#+md: <div class="grid" markdown>
#+md: <div class="bvr-full-height-image-wrapper" markdown>
#+attr_latex: :width \linewidth
#+caption: BFS on Graph A
#+name: fig:bfsOnGraphA
[[file:images/bfsOnGraphA.png]]

#+md: _BFS on Graph A_
#+md: </div>

#+md: <div markdown>
**** Key Insight
All the three questions here speak about a shortest
path originating from vertex $u$.  This is a uniformly
weighted undirected graph, /i.e./ all edges are equally
weighted.  The solution for shortest path will follow a
BFS in such a case.

**** Solution
1. Running a BFS on the graph gives us the figure, “BFS
   on Graph A” @@latex:(Fig~\ref{fig:bfsOnGraphA})@@
   upon termination.
2. The numbers marked are discovery times of the nodes \\
   $v\cdot d \ \forall v\in V$.
3. For part (1) the shortest path weight is given as
   $\delta(u,j) = j\cdot d - u\cdot d$.  Computing from
   the figure, $\delta(u,j) = 4-0 = 4$.
4. For part (2) we may pick any one path such that each
   successive node is from successive level.  /i.e./
   one of,
   1. $\langle u,v,h,i,j\rangle$,
   2. $\langle u,v,w,y,j\rangle$, or
   3. $\langle u,v,x,y,j\rangle$.

   Recall, that only one of these is, and not all of
   them are, the required shortest path (/i.e./
   discovered in one run).

5. For part (3), a BFS tree is required.  It’s been
   left that upon the reader to exercise and present as
   necessary.  An easy way out would be to use the
   adjoining graph
   @@latex:(Fig~\ref{fig:bfsOnGraphA})@@ and
   additionally mark each connection from “parent” to
   “child” as descended during the BFS.  Note that the
   arrow would be a manifestation of line =v.PI = u= in
   the algorithm [[https://docs.google.com/presentation/d/14PY-Sc50QsFxdUqZk7GlYVwwEXzO38rg9z9KKx5ti0k/edit#slide=id.g32a7028b731_0_60][(link to the slide)]].  Recall that
   there may be only one parent to a child, not many,
   and that the discovery time of the parent is always
   less than that of the child.
#+md: </div>
#+md: </div>

** DFS

**** Question
Given that there are 10 courses in a programme, and
corresponding pre-requisites are listed as under,
*determine algorithmically* If the programme may be
completed successfully by a candidate?

4. [@4] depends upon 1 and 2;
5. depends upon 1, 3 and 10;
6. depends upon 2 and 3;
7. depends upon 2, 4 and 5;
8. depends upon 1 and 4;
9. depends upon 5 and 6; and
10. depends upon 3 and 7.

**** Key Insight
We define a relationship $u\to v$ if course $u$ depends
upon $v$.  Then we get a dependency graph (/i.e./ a
directed graph where relationship is defined when the
parent is dependent upon the child).

A topological order $T\equiv\langle v_{1},\ldots,v_{k}
\rangle$ of such a graph means that all ancestors of
$v_{i}$ have been listed before $v_{i}$ itself $\forall
v_{i}\in V$.  In simple words, the topological order is
one possible order of courses to complete the
programme.

However, the topological order is not always possible.
From [[https://docs.google.com/presentation/d/14PY-Sc50QsFxdUqZk7GlYVwwEXzO38rg9z9KKx5ti0k/edit#slide=id.g32a7028b731_0_377][our slides]], we know that topological order is only
defined for directed acyclic graph (DAG).  *Hence, one
may complete the programme if the dependency graph is
acyclic.*

And *a graph is acyclic if and only if there are no
back edges.*

**** Solution
#+md: <div class="grid" markdown>
#+md: <div markdown>
1. Run a DFS on Dependency Graph;
2. Maintain a list $T$ for Topological Order;
3. Upon finishing the visit to a node, insert the node
   to the front of the list;
4. Exit “abnormally,” if encountered a “back edge.”

If exited abnormally, the graph is acyclic; and the
programme can not be completed successfully.

Otherwise, $T$ contains an order of courses that
successfully completes the programme.

In figure “DFS on Dependency Graph,”
@@latex:(Fig~\ref{fig:dfsOnDependencyGraph})@@ nodes
have been mentioned with discovery and finish times;
and edges has been labelled as B,C,F,T for back edges,
cross edges, forward edges and tree edges respectively.

The algorithm terminated upon visiting the edge $7\to
5$ which is a back edge (labelled B).

*Hence the programme can not be completed.*
#+md: </div>
#+md: <div class="bvr-full-height-image-wrapper" markdown>
#+caption: DFS on Dependency Graph
#+name: fig:dfsOnDependencyGraph
[[file:images/dfsOnDependencyGraph.png]]

#+md: _DFS on the Dependency Graph_
#+md: </div>
#+md: </div>



